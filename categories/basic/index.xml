<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Basic on Lazytrick</title>
    <link>https://blog.lazytrick.com/categories/basic/</link>
    <description>Recent content in Basic on Lazytrick</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>&amp;copy; 2019 Minatu2d</copyright>
    <lastBuildDate>Wed, 06 Feb 2019 07:26:15 +0900</lastBuildDate>
    
	<atom:link href="https://blog.lazytrick.com/categories/basic/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Bắt đầu về Docker</title>
      <link>https://blog.lazytrick.com/post/2019-02-06-bat-dau-ve-docker/</link>
      <pubDate>Wed, 06 Feb 2019 07:26:15 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2019-02-06-bat-dau-ve-docker/</guid>
      <description>Docker, là công nghệ rất nổi và có ảnh hưởng đến hầu hết developer.
Được coi là một công nghệ ảo hóa ở mức hệ điều hành khi so với các phương pháp ảo hóa phần cứng khác.
Theo mình hỏi, kĩ thuật để làm việc này không mới, nó dựa trên kĩ thuật chroot có được sử dụng từ khá lâu trong linux.
Nói là vậy, nhưng học để sử dụng thì cần bài bản chút, bài này mình sẽ tóm tắt lại trang Overview từ trang của Docker</description>
    </item>
    
    <item>
      <title>Thực hiện 3 phép tập hợp trên bash</title>
      <link>https://blog.lazytrick.com/post/2017-11-03-thuc-hien-3-phep-tap-hop-tren-bash/</link>
      <pubDate>Fri, 03 Nov 2017 09:02:16 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2017-11-03-thuc-hien-3-phep-tap-hop-tren-bash/</guid>
      <description>Gần đây do phải làm việc crawling dữ liệu, nên có một chút ít động đến các phép toán tập hợp.
Bài này sử dụng để note lại các câu lệnh để thực hiện các phép toán phổ biến với tập hợp.
Nội dung được dịch từ bài viết khá chi tiết của pro Peter Krumins chủ trang http://www.catonmat.net/
1. Phép giao Có rất nhiều cách để tìm giao của 2 tập hơn trong bash.</description>
    </item>
    
    <item>
      <title>Một số thứ khi sử dụng command, viết script trong bash</title>
      <link>https://blog.lazytrick.com/post/2017-11-03-mot-so-thu-khi-su-dung-command-viet-script-trong-bash/</link>
      <pubDate>Fri, 03 Nov 2017 06:31:11 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2017-11-03-mot-so-thu-khi-su-dung-command-viet-script-trong-bash/</guid>
      <description>Bài này xin được trích rút một số thứ hữu ích từ bài viết rất hay tên The art of command line và mình cũng đã dịch thử (chưa được review) ở
Nghệ thuật sử dụng dòng lệnh
1. Hạn chế gõ lại câu lệnh cho dù là rất ngắn Hãy sử dụng chức năng tìm đoạn đang gõ trong history để làm giảm công gõ lại
Hai chức năng tìm xuôi và tìm ngược được bash cung cấp rồi.</description>
    </item>
    
    <item>
      <title>Ví dụ cơ bản với pthread trên Linux</title>
      <link>https://blog.lazytrick.com/post/2017-05-20-vi-du-co-ban-voi-pthread-tren-linux/</link>
      <pubDate>Sat, 20 May 2017 15:50:20 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2017-05-20-vi-du-co-ban-voi-pthread-tren-linux/</guid>
      <description>1. Tạo và dừng thread Source code gốc lấy từ link
/****************************************************************************** * FILE: hello.c * DESCRIPTION: * Chuong trinh demo thao tac tao thread, tat thread * AUTHOR: Blaise Barney * LAST REVISED: 08/09/11 * * TRANSLATE to Vietnamese by Minatu * COMPILE CMD : $gcc -o hello hello.c -lpthread ******************************************************************************/ // #include &amp;lt;pthread.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#define NUM_THREADS 5  void *PrintHello(void *threadid) { long tid; tid = (long)threadid; printf(&amp;#34;Hello World!</description>
    </item>
    
    <item>
      <title>So sánh nhỏ về cú pháp câu lệnh ASM giữa AT&amp;T và Intel</title>
      <link>https://blog.lazytrick.com/post/2017-05-14-so-sanh-nho-ve-cu-phap-cau-lenh-asm-giua-att-va-intel/</link>
      <pubDate>Sun, 14 May 2017 08:43:10 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2017-05-14-so-sanh-nho-ve-cu-phap-cau-lenh-asm-giua-att-va-intel/</guid>
      <description>Link gốc:
http://www.imada.sdu.dk/Courses/DM18/Litteratur/IntelnATT.htm
Người dịch:
Ngôn ngữ Assembly không phải là ngôn ngữ tốt để viết ứng dụng,nhất là bây giờ đã là năm 2017. Có quá nhiều thứ hiệu quả và nhanh hơn. Tuy nhiên, khi cần tìm hiểu ở mức hệ điều hành, rồi driver thiết bị, thì việc đọc được Assembly là rất hữu ích.
Nội dung
Cú pháp ASM giữa Intel và AT&amp;amp;T có rất nhiều điềm khác nhau rõ rệt.</description>
    </item>
    
    <item>
      <title>Lệnh MOV trong Assembly</title>
      <link>https://blog.lazytrick.com/post/2017-05-14-lenh-mov-trong-assembly/</link>
      <pubDate>Sun, 14 May 2017 07:59:46 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2017-05-14-lenh-mov-trong-assembly/</guid>
      <description>Link gốc: http://www5c.biglobe.ne.jp/~ecb/assembler/2_1.html
1. Lệnh MOV Lệnh MOV, có thể nói là lệnh cơ bản nhất, có tần số sử dụng nhiều nhất trong bất cứ hệ tính toàn nào.
Làm bất cứ cái gì, đều có bao gồm sao chép dữ liệu trong đó. Nói là chức năng sao chép thôi, chứ thực sự nó bao hàm sao chép, truyền dữ liệu. Đó có thể là từ bộ nhớ (các loại RAM) vào thanh ghi, từ thanh ghi vào bộ nhớ, từ một giá trị nào đó xuống thanh ghi hoặc bộ nhớ chẳng hạn.</description>
    </item>
    
    <item>
      <title>Tìm source code của USB Driver trên Linux</title>
      <link>https://blog.lazytrick.com/post/2017-04-23-tim-source-code-cua-usb-driver-tren-linux/</link>
      <pubDate>Sun, 23 Apr 2017 04:10:05 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2017-04-23-tim-source-code-cua-usb-driver-tren-linux/</guid>
      <description>Ở bài Tìm driver cho Linux cũng đã nói qua rồi, nhưng bài này muốn chỉ ra chi tiết hơn một chú cho nhưng ai muốn đọc source.
Cách tìm source code driver cho thiết bị USB
1. Nói qua về thiết bị USB  Linux kernel xác định driver phù hợp cho thiết bị bằng 2 thông tin chính.
Đó là Vendor (nhà sản xuất), và Product (sản phẩm).</description>
    </item>
    
    <item>
      <title>Build, chạy nhân Linux trong QEMU ARM</title>
      <link>https://blog.lazytrick.com/post/2017-04-10-build-chay-nhan-trong-qemu-arm/</link>
      <pubDate>Mon, 10 Apr 2017 14:07:48 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2017-04-10-build-chay-nhan-trong-qemu-arm/</guid>
      <description>Chạy một bản Linux tối giản trên Qemu ARM
Bài này sẽ làm một ví dụ để chỉ ra sự liên quan giữa
các thành phần của một hệ thống Linux thông qua
việc build, chạy Kernel trên board vexpress-a9 mô phỏng bằng Qemu.
Đó là Kernel, Root file system, Busybox, Init.
1. &amp;ldquo;Chém&amp;rdquo; chút về quá trình khởi động của Linux  Về cơ bản, quá trình khởi động Linux có 2 giai đoạn.</description>
    </item>
    
    <item>
      <title>4 thành phần của Embedded Linux</title>
      <link>https://blog.lazytrick.com/post/2017-04-02-4-thanh-phan-cua-embedded-linux/</link>
      <pubDate>Sun, 02 Apr 2017 14:29:17 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2017-04-02-4-thanh-phan-cua-embedded-linux/</guid>
      <description>Ta biết rằng Linux chạy ở khắp nơi từ siêu máy tính, máy chủ, máy để bàn (máy xách tay), điện thoại (android)&amp;hellip;cho đến các thiết bị gia dụng, gia đình.
Khi sử dụng máy tính cá nhân, server ta dễ dàng &amp;ldquo;sờ&amp;rdquo; thấy được các thành phần của Linux như các tiến trình, shell..etc.
Hầu hết các bản phân phối phổ biến làm hết những thứ liên quan đến phần cứng, nhân hệ điều hành, driver cho ta rồi.</description>
    </item>
    
    <item>
      <title>Một vài lệnh Bitbake hữu dụng</title>
      <link>https://blog.lazytrick.com/post/2017-02-19-mot-vai-lenh-bitbake-huu-dung/</link>
      <pubDate>Sun, 19 Feb 2017 00:14:48 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2017-02-19-mot-vai-lenh-bitbake-huu-dung/</guid>
      <description>Có một vài lệnh hữu dụng được cộng đồng sử dụng board NXP chia sẻ, mình sẽ note ở đây cho dễ tìm vậy. Link tại đây.
Lệnh Bitbake
**Miêu tả
**
bitbake 
Nấu ra 1 &amp;ldquo;ảnh&amp;rdquo; (Image) (Thêm tham số _-k đ_ể cho phép chạy đến hết kẻ cả có lỗi thực thi)
bitbake  -c 
Thực hiện 1 task của package nào đó. Tên các task mặc định thường có: _fetch,_ unpack, patch, configure, compile, install, package, package_write, and build.</description>
    </item>
    
    <item>
      <title>Giới thiệu về lập trình Assembly trên Linux (AT&amp;T Style không phải Intel Style)</title>
      <link>https://blog.lazytrick.com/post/2017-02-11-gioi-thieu-ve-lap-trinh-assembly-tren-linux-att-style-khong-phai-intel-style/</link>
      <pubDate>Sat, 11 Feb 2017 12:47:50 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2017-02-11-gioi-thieu-ve-lap-trinh-assembly-tren-linux-att-style-khong-phai-intel-style/</guid>
      <description>Tham khảo
- Sách : AT&amp;amp;T Assembly Language, Richard Blum
1. Ngôn ngữ Assembly là gì?  Ở mức thấp nhất, Process chỉ hiểu instruction code Instruction Code là các mã nhị phân chứa các thành phần: Instruction prefix, Opcode, ModR/M, SIB, Displacement, Data Element. Người ta hoàn toàn có thể viết chương trình bằng instruction code, nhưng nó sẽ cực kì khó nhọc, bởi ta chỉ thấy không gì khác ngoài các byte nối tiếp nhau.</description>
    </item>
    
    <item>
      <title>So sánh giữa Buildroot và Yocto Project</title>
      <link>https://blog.lazytrick.com/post/2017-01-20-so-sanh-buildroot-va-yocto-project/</link>
      <pubDate>Fri, 20 Jan 2017 01:22:46 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2017-01-20-so-sanh-buildroot-va-yocto-project/</guid>
      <description>Bài này sẽ dịch lại Slide thảo luận giữa 2 diễn giả là Alexandre Belloni, Thomas Petazzoni
từ Free Electrons tại Embedded Linux Conference 2016.
So sánh giữa Buildroot và OpenEmbedded/Yocto Project
1. Điểm chung  Đều là build-system cho Embedded Linux.
Mục tiêu là có thể customize, build hoàn chỉnh một Embedded Linux System.
Bao gồm: filesystem, toolchain, kernel, bootloaders Đều được build từ source Sử dụng cross-compilation Rất actively trong cả dự án đang maintained và phát triển.</description>
    </item>
    
    <item>
      <title>Về /dev trong Embedded Linux</title>
      <link>https://blog.lazytrick.com/post/2017-01-19-ve-dev-trong-embedded-linux/</link>
      <pubDate>Thu, 19 Jan 2017 16:19:32 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2017-01-19-ve-dev-trong-embedded-linux/</guid>
      <description>Đây là nội dung pick up từ manual của Buildroot.
Nó mô tả khá rõ về /dev trong hệ thống Linux, cùng
với các giải pháp dành cho hệ thống Embedded Linux.
6.2 /dev management Trên 1 hệ thống Linux, thư mục /dev chứa các file đặc biệt, được gọi là
device files (hay các file thiết bị), cho phép ứng dụng phía user truy cập
đến các thiết bị phần cứng mà Linux kernel quản lý.</description>
    </item>
    
    <item>
      <title>Thực hiện 4 Stage khi Compile bằng tay (Manual)</title>
      <link>https://blog.lazytrick.com/post/2017-01-08-thuc-hien-4-stage-khi-compile-bang-tay-manual/</link>
      <pubDate>Sun, 08 Jan 2017 06:18:19 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2017-01-08-thuc-hien-4-stage-khi-compile-bang-tay-manual/</guid>
      <description>Ta đã có bài giới thiệu về 4 Stage khi Compiling rồi. Đầu ra của Stage trước sẽ là đầu vào của Stage sau.
Trong compile thông thường dạng
$gcc -o HelloWorld HelloWorld.c  Với câu lệnh trên,ta sẽ không thấy kết quả của 3 Stage đầu tiên.
Để hiểu rõ hơn, chúng ta hãy thử thực hiện các Stage bằng tay xem liệu ta có thể tạo ra file chạy như câu lệnh compile trên hay không.</description>
    </item>
    
    <item>
      <title>4 Stage khi biên dịch HelloWorld.c</title>
      <link>https://blog.lazytrick.com/post/2017-01-01-4-stage-khi-bien-dich-helloworld-c/</link>
      <pubDate>Sun, 01 Jan 2017 22:00:04 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2017-01-01-4-stage-khi-bien-dich-helloworld-c/</guid>
      <description>Gần đây, phải giải quyết giúp một vài vấn đề liên quan đến Cross-Compile. Có tìm hiểu kĩ một chú về Compiler, Linker, và Loader.
Bài này xin nói về cơ bản về quá trình biên dịch một file source code (.c) sang dạng chạy được.
Ví dụ: từ HelloWorld.c thành HelloWorld và chạy được như ví dụ dưới đây.
HelloWorld.c
#include int main() { print(&amp;#34;Hello World \\n&amp;#34;); return 0; }  Kết quả chạy:</description>
    </item>
    
    <item>
      <title>Một chút hiểu thêm về &#34;Hello World&#34; trong C.</title>
      <link>https://blog.lazytrick.com/post/2016-12-21-mot-chut-hieu-them-ve-hello-world-trong-c/</link>
      <pubDate>Wed, 21 Dec 2016 05:31:09 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2016-12-21-mot-chut-hieu-them-ve-hello-world-trong-c/</guid>
      <description>Gần đây, gặp một số vấn đề về Loader-Linker giữa môi trường build và môi trường chạy trong Cross-Compiling.
Có thể bất kì chương nào trong Linux cũng vậy. Nhưng chỉ xét một chường trình được build bằng C thì
một chương trình sẽ được chạy 2 cách dưới đây
1. Chương trình hoàn toàn là tĩnh  Không có symbol nào cần phải được (resolved) trước khi chạy. Không yêu cầu bất cứ một thư viện run-time nào.</description>
    </item>
    
    <item>
      <title>PER trong ASN.1 Encoding</title>
      <link>https://blog.lazytrick.com/post/2016-11-29-per-trong-asn-1-encoding/</link>
      <pubDate>Tue, 29 Nov 2016 14:48:30 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2016-11-29-per-trong-asn-1-encoding/</guid>
      <description>PER là phương thức biểu diễn dữ liệu ngắn gọn và xúc tích nhất có thể của ASN.1. Thay vì sử dụng TLV như BER, PER sử dụng Preamble (diễn cho nhiều hoặc trạng thái bị lược bỏ của một dữ liệu bên trong), giá trị kích thước(cũng có thể bị lược bỏ), giá trị (cũng có thể bị lược bỏ), hay gọi là PLV.
Đơn vị biểu diễn của PER không phải Octet mà là Bit.</description>
    </item>
    
    <item>
      <title>CER/DER trong ASN.1 Encoding</title>
      <link>https://blog.lazytrick.com/post/2016-11-25-phuong-thuc-cerder/</link>
      <pubDate>Fri, 25 Nov 2016 14:43:11 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2016-11-25-phuong-thuc-cerder/</guid>
      <description>Khi sử dụng BER để hiện thực dữ liêu, ta thấy rằng có khá nhiều chỗ tùy ý. Tức là cùng một thông tin có nhiều cách biểu diễn khác nhau. Khi sử dụng với trường hợp chữ kí Số, phát sinh ra nhiều vấn đề.
Để giải quyết những vấn đề đó, người ta thêm ràng buộc vào BER, và tạo ra CER và DER.
Sự khác nhau chủ yếu giữa CER và DER là về biểu diễn trường độ dài.</description>
    </item>
    
    <item>
      <title>ASN.1 - BER (Basic Encoding Rules)</title>
      <link>https://blog.lazytrick.com/post/2016-11-24-asn-1-ber-basic-encoding-rules/</link>
      <pubDate>Thu, 24 Nov 2016 15:58:01 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2016-11-24-asn-1-ber-basic-encoding-rules/</guid>
      <description>Tiếp tục về ASN.1.
Như bài đầu tiên, ASN.1 tách biệt phần định nghĩa dữ liệu (các file định nghĩa) với phần hiện thực dữ liệu (mỗi trường được biểu diễn bằng mấy byte, mấy bit, etc)
Ta sẽ tiếp tục nói về hiện thực dữ liệu.
Các phương thức để hiện thực dữ liệu gồm có: BER, CER/DER, và PER.
Trong đó:
BER : Basic Encoding Rules
CER/DER : Canonical Encoding Rules/Distinguished Encoding Rules</description>
    </item>
    
    <item>
      <title>ASN.1 - Cú pháp cơ bản</title>
      <link>https://blog.lazytrick.com/post/2016-11-16-asn-1-cu-phap-co-ban/</link>
      <pubDate>Wed, 16 Nov 2016 15:49:05 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2016-11-16-asn-1-cu-phap-co-ban/</guid>
      <description>Tiếp theo loạt bài về ASN.1, bài này sẽ &amp;ldquo;dịch&amp;rdquo; tài liệu của anh Isida So nói về cú pháp cơ bản của ASN.1.
Việc đầu tiên khi ứng dụng ASN.1 hoặc thiết kế một giao thức mới là viết định nghĩa cho các kiểu dữ liệu có thể được sử dụng.
ASN.1 là một ngôn ngữ vì thế, cũng giống với C, nó có các kiểu cơ bản và các cơ chế cho phép mở rộng để định nghĩa thêm các kiểu mới.</description>
    </item>
    
    <item>
      <title>ASN.1 là gì? Tại sao nó quan trọng.</title>
      <link>https://blog.lazytrick.com/post/2016-11-12-asn-1-la-gi-tai-sao-no-quan-trong/</link>
      <pubDate>Sat, 12 Nov 2016 08:51:58 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2016-11-12-asn-1-la-gi-tai-sao-no-quan-trong/</guid>
      <description>Mình thấy ASN.1 khá quan trọng nhất là trong thiết kế giao thức trao đổi dữ liệu giữa các thiết bị tính toán, đặc biệt là các thiết bị tài nguyên nhỏ.
Google tiếng Việt thấy khá ít thông tin về ASN.1.
Mình dự định sẽ tìm hiểu thêm một chút về ASN.1 và làm loại bài viết về nó.
Nội dung bài này sẽ giới thiệu sơ qua về ASN.</description>
    </item>
    
    <item>
      <title>&#34;Data structure alignment&#34; là gì? Tại sao phải hiểu nó khi code C.</title>
      <link>https://blog.lazytrick.com/post/2016-10-26-data-structure-alignment-la-gi-tai-sao-phai-hieu-no-khi-code-c/</link>
      <pubDate>Wed, 26 Oct 2016 06:50:13 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2016-10-26-data-structure-alignment-la-gi-tai-sao-phai-hieu-no-khi-code-c/</guid>
      <description>Đây là một chủ đề hay, có rất nhiều resource bằng tiếng Việt khá dễ hiểu rồi.
Bài này chỉ mô tả ngắn gọn một chút cùng với vài ví dụ thực nghiệm để hiểu các khái niệm về cơ bản về Data Structure Aligment.
Giả sử ta có một cấu trúc sau:
#include &amp;lt;stdint.h&amp;gt; typedef struct { uin8_t mem1; uin8_t mem2; uin32_t mem3; }ST_FOOL_1; typedef struct { uin8_t mem1; uin8_t mem2; uin8_t mem3; uin8_t mem4; uin8_t mem5; }ST_FOOL_2;  Cấu trúc ST_FOOL_1 sẽ được miêu tả trong 6 byte?</description>
    </item>
    
    <item>
      <title>GDB dòng lệnh cơ bản (03 - Cơ bản)</title>
      <link>https://blog.lazytrick.com/post/2016-10-19-gdb-do-lenh-co-ban-03-co-ban/</link>
      <pubDate>Wed, 19 Oct 2016 14:27:19 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2016-10-19-gdb-do-lenh-co-ban-03-co-ban/</guid>
      <description>Trong bài số 02, ta đã nói đến những việc mà GDB có thể giúp chúng ta.
Về cơ bản GDB, có thể chạy để debug mọi chương trình, tuy nhiên nếu không muốn càng debug càng rối thì ta nên sử dụng tham số -g khi biên dịch để giúp quá trình debug xác định được vị trí mỗi đoạn binary trong source ban đầu.
Trong bài này, ta hãy cùng xem cách sử dụng thực tế sẽ như thế nào.</description>
    </item>
    
    <item>
      <title>Cài đặt GDB (02 - Cài đặt)</title>
      <link>https://blog.lazytrick.com/post/2016-09-20-cai-dat-gdb-02-cai-dat/</link>
      <pubDate>Tue, 20 Sep 2016 08:42:17 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2016-09-20-cai-dat-gdb-02-cai-dat/</guid>
      <description>Khi sử dụng GDB để debug 1 chương trình thì chương trình đó gọi là target program.
Khi nói về vị trí của GDB dùng để debug và target program, ta sẽ có 2 cách trường hợp sử dụng sau:
 GDB và target program cùng ở 1 máy : Thường sử dụng với chính các chương trình được dev, rồi build, rồi chạy trên máy đó. Đây là trường hợp chúng ta hay thấy nhất, đó là khi phát triển các app desktop.</description>
    </item>
    
    <item>
      <title>GDB có thể làm gì? (01 - Khả năng của GDB)</title>
      <link>https://blog.lazytrick.com/post/2016-09-19-gdb-co-the-lam-gi/</link>
      <pubDate>Mon, 19 Sep 2016 11:58:27 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2016-09-19-gdb-co-the-lam-gi/</guid>
      <description>Trước khi nói về chủ đề chính là &amp;ldquo;GDB có thể làm gì&amp;rdquo;. GDB hay những phần mềm như GDB được viết ra để giải quyết vấn đề gì.
1. Phầm mềm Debugger sinh ra giải quyết cái gì? Phần mềm thực sự được tạo ra ở bước implementation, nó hiện thực những nội dung được mô tả trong thiết kế.
Vì con người viết code tạo ra phần mềm, mà con người không phải lúc nào cũng luôn làm đúng như những gì họ đã nghĩ, đã ý định, đã thiết kế.</description>
    </item>
    
    <item>
      <title>Làm việc với GDB - GNU Debugger (00- Mở đầu)</title>
      <link>https://blog.lazytrick.com/post/2016-09-15-lam-viec-voi-gdb-gnu-debugger-00-mo-dau/</link>
      <pubDate>Thu, 15 Sep 2016 09:19:53 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2016-09-15-lam-viec-voi-gdb-gnu-debugger-00-mo-dau/</guid>
      <description>Đợt này ngồi Unit Test nhiều quá, mệt!!!. Mà đã mệt, sinh ra chán để tiếp tục được thì nhất phải có gì hay ho thỉnh thoảng ngó sang tí cho đỡ chán. それはアカン！！！！
Cách đặt mục tiêu để viết, dịch khá hiệu quả đối với &amp;ldquo;siêu lười&amp;rdquo; như mình, loạt về USB Basic dù nội dung chắc nhiều lỗi những ít ra nó cũng hoàn thành.
Vâng, mục tiêu lần này sẽ viết một loạt bài về cách sử dụng GDB (GNU Debugger) từ cài đặt, cách sử dụng dòng lệnh đến các IDE (Eclipse hoặc VS Studio).</description>
    </item>
    
    <item>
      <title>AWK - Sử dụng cơ bản</title>
      <link>https://blog.lazytrick.com/post/2016-09-07-awk-su-dung-co-ban/</link>
      <pubDate>Wed, 07 Sep 2016 09:25:06 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2016-09-07-awk-su-dung-co-ban/</guid>
      <description>AWK : 1 trong 3 tool (cùng với grep và sed) mạnh dùng xử lý chuỗi, xuất hiện ban đầu ở Unix, và được mặc định có trong bất cứ bản phân phối Linux nào.
Sau một hồi tìm hiểu awk trên TutorialPoint.
awk là một một tool để xử lý một chuỗi, đầu vào có thể là file, là output của một câu lệnh khác. Đơn vị xử lý là dòng, tức là nó đọc vào từng dòng text từ dữ liệu đầu vào rồi thực hiện các xử lý tương ứng.</description>
    </item>
    
    <item>
      <title>Sử dụng Patch và Diff</title>
      <link>https://blog.lazytrick.com/post/2016-09-02-su-dung-patch-vs-diff/</link>
      <pubDate>Fri, 02 Sep 2016 08:53:59 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2016-09-02-su-dung-patch-vs-diff/</guid>
      <description>Patch, hay người ta vẫn gọi là các bản vá, víu gì đó. Cũng thấy khái niệm này từ lâu rồi. Nhưng chưa bao giờ phát sinh nhu cầu sử dụng vì đa số các dự án mình từng làm đều dùng Server SVN tập trung. Mọi thay đổi đều có quản lý chặt chẽ, cũng ít khi rẽ quá nhiều nhánh (branch).
Gần đây, bắt buộc phải nghĩ đến việc sử dụng 2 tool này vì phải update source trên máy thật (một board mạch) chỉ hỗ trợ truyền Serial.</description>
    </item>
    
    <item>
      <title>Driver và Firmware trong Linux</title>
      <link>https://blog.lazytrick.com/post/2016-08-29-khai-niem-driver-va-firmware-trong-linux/</link>
      <pubDate>Mon, 29 Aug 2016 08:25:25 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2016-08-29-khai-niem-driver-va-firmware-trong-linux/</guid>
      <description>Gần đây, khi tìm hiểu cách cài đặt driver cho USB Wifi, mình có tìm hiểu thêm về quá trình tạo nhân Linux. Đặc biệt, việc thiết lập cấu hình trước khi build tạo ảnh của kernel.
Mình thấy ngoài Driver, tức là thành phần trung gian giữa ứng dụng và phần cứng, còn có 1 khái niệm nữa. Đó là Firmware.
Bài này sẽ dịch lại trang, để hiểu qua về Firmware trong Linux Kernel.</description>
    </item>
    
    <item>
      <title>Tìm Driver cho Linux</title>
      <link>https://blog.lazytrick.com/post/2016-08-19-xac-dinh-cac-driver-module-dang-duoc-su-dung-tren-linux/</link>
      <pubDate>Fri, 19 Aug 2016 01:38:50 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2016-08-19-xac-dinh-cac-driver-module-dang-duoc-su-dung-tren-linux/</guid>
      <description>Trong quá trình tìm cách cài đặt driver cho bản build Raspberry PI sử dụng Yocto, mình có tìm hiểu driver trong Linux và tìm được cuốn sách Linux in A Nutshell (link tại đây ) của pro này.
Chương 7, chương mà tác giả đặc biệt &amp;ldquo;tự hào&amp;rdquo;, nói về Customize một Linux Kernel.
Trong chương này, tác giả cũng nói đến việc xác định các driver đang được sử dụng trên hệ thống hiện tại.</description>
    </item>
    
    <item>
      <title>Hệ thống File Ubifs</title>
      <link>https://blog.lazytrick.com/post/2016-08-05-luot-qua-he-thong-file-ubifs/</link>
      <pubDate>Fri, 05 Aug 2016 01:50:50 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2016-08-05-luot-qua-he-thong-file-ubifs/</guid>
      <description>Gần đây, có thấy trên Board mạch phát triển của mình có xuất hiện 1 process là ubifs. Qua tìm hiểu mới biết rằng, em nó là UBIFS, được phát triển năm 2007 bởi Nokia với sự giúp đỡ của University of Szeged, Hungary.
Bắt đầu được đưa vào mainline của Linux 2.6.27 năm 2008.
Hỏi thấy GG thấy được 1 bài giới thiệu chung về hệ thống file cho thiết bị nhớ Flash của anh Le Dinh Thao trên blog kithuatmaytinh.</description>
    </item>
    
    <item>
      <title>Phân biệt Build vs Host vs Target</title>
      <link>https://blog.lazytrick.com/post/2016-08-03-cac-khai-niem-trong-cross-compiling/</link>
      <pubDate>Wed, 03 Aug 2016 01:24:36 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2016-08-03-cac-khai-niem-trong-cross-compiling/</guid>
      <description>Khái niệm Cross-compiling là rất phổ biến khi phát triển các hệ thống nhúng.
Với người mới, hiểu rõ khái niệm là rất quan trọng.
Bài này sẽ cố gắng phân biệt 3 khái niệm về môi trường. Đó là Host Enviroment, Build Enviroment, và Target Enviroment. Có thể dịch nôm na là Môi trường chủ, Môi trường biên dịch, và Môi trường chạy đích.
Vì có thể dẫn đến hiểu nhầm hoặc không rõ nghĩa nên chúng ta nên sử dụng trực tiếp thì hơn.</description>
    </item>
    
    <item>
      <title>USB cho dev (Chap.06 – Các gói tin Setup)</title>
      <link>https://blog.lazytrick.com/post/2016-07-23-usb-cho-dev-chap-06-cac-goi-tin-setup-chua-xong/</link>
      <pubDate>Sat, 23 Jul 2016 05:46:28 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2016-07-23-usb-cho-dev-chap-06-cac-goi-tin-setup-chua-xong/</guid>
      <description>Mỗi thiết bị USB phải trả lời các gói tin Setup (Setup packets) trên Endpoint mặc định (Endpoint Zero). Các gói tin Setup được sử dụng cho việc phát hiện thiết bị, cấu hình, cũng như lấy các thông tin khác như các thông tin về chức năng, địa chỉ thiết bị, kiểm tra trạng thái các Endpoint.
Chuẩn USB yêu cầu Host sẽ mon muốn về mặt thời gian từ phát hiện đến lấy đầy đủ các thông tin trên trong vòng không quá 5 giây.</description>
    </item>
    
    <item>
      <title>USB cho dev (Chap.05 – Đặc tả thiết bị)</title>
      <link>https://blog.lazytrick.com/post/2016-07-18-usb-cho-dev-chap-05-dac-ta-thiet-bi/</link>
      <pubDate>Mon, 18 Jul 2016 09:19:07 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2016-07-18-usb-cho-dev-chap-05-dac-ta-thiet-bi/</guid>
      <description>Tất cả các thiết bị nằm trong 1 hệ thống phân cấp các miêu tả (hierachy of descriptors), miêu tả cho Host biết các thông tin về Thiết bị gì?Nhà sản xuất? Phiên bản của giao thức USB nó hỗ trợ?Các cách để cấu hình? Số lượng Endpoint và loại truyền tương ứng.
Các đặc tả phổ biết nhất bao gồm:
 Miêu tả thiết bị (Device Descriptors) Miêu tả các cấu hình (Configuration Descriptors) Miêu tả giao diện (Interface Descriptors) Miêu tả điểm đầu cuối (EndPoint Descriptors) Các chuỗi sử dụng trong các miêu tả trên.</description>
    </item>
    
    <item>
      <title>2 cách sử dụng thư viện trong Linux</title>
      <link>https://blog.lazytrick.com/post/2016-06-12-2-cach-su-dung-thu-vien-trong-linux/</link>
      <pubDate>Sun, 12 Jun 2016 13:20:13 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2016-06-12-2-cach-su-dung-thu-vien-trong-linux/</guid>
      <description>Mình đang gặp 1 vấn đề là 1 hàm F1() trong thư viện động mình viết (lib1.so) không hoạt động đúng như mong muốn. Trong hàm _F1()_có gọi một loại hàm F21(), F22(), F23()&amp;hellip;F2n() từ 1 thư viện tĩnh (lib2.a) khác.
Khi build không gặp lỗi,
Khi biên dịch thư viện động này với 1 file sample.c để chưa main() để chạy thử và gọi hàm _F1() _từ thư viện động lib1.</description>
    </item>
    
    <item>
      <title>USB cho dev (Chap.04 - Các loại Endpoint)</title>
      <link>https://blog.lazytrick.com/post/2016-03-26-usb-cho-dev-chap-04-cac-loai-endpoint/</link>
      <pubDate>Sat, 26 Mar 2016 03:11:25 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2016-03-26-usb-cho-dev-chap-04-cac-loai-endpoint/</guid>
      <description>Đặc tả USB định nghĩa 4 loại Transfer/EndPoint
Control Transfer
Interrupt Transfer
Isochronous Transfer
Bulk Transfer
Control Transfer (Truyền điều khiển) Control Transfer thường được sử dụng cho Commands và Status. Đây là loại truyền chủ yếu được sử dụng trong suốt quá trình Enumeration. Ở dạng truyền này, các gói tin được gửi theo phương trâm best effort delivery (gửi đến khi nào nhận được thì tính tiếp). Độ dài mỗi packet trong dạng truyền control ở mỗi speed lại khác nhau.</description>
    </item>
    
    <item>
      <title>USB cho dev (Chap.03 - Giao thức)</title>
      <link>https://blog.lazytrick.com/post/2016-03-21-usb-cho-dev-chap-03-giao-thuc/</link>
      <pubDate>Mon, 21 Mar 2016 15:19:47 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2016-03-21-usb-cho-dev-chap-03-giao-thuc/</guid>
      <description>Không giống như RS-232 và nhiều giao tiếp tuần tự khác, cái mà không định nghĩa dạng dữ liệu được gửi. USB được tạo bởi nhiều lớp protocol. Nghe có vẻ &amp;ldquo;nguy hiểm&amp;rdquo;, nhưng cứ bình tõm, nó không ghê gớm đến thế đâu. Một khi bạn hiểu cái gì đang diễn ra thì cái bạn thực sự phải bỏ công sức vào chỉ là các lớp ở tầng trên thôi.</description>
    </item>
    
    <item>
      <title>USB cho Dev (Chp.02 - Phần cứng)</title>
      <link>https://blog.lazytrick.com/post/2016-03-21-usb-cho-dev-chp-02-phan-cung/</link>
      <pubDate>Mon, 21 Mar 2016 02:17:04 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2016-03-21-usb-cho-dev-chp-02-phan-cung/</guid>
      <description>Tiếp theo bài chương đầu tiên về USB, chương này sẽ nói về phần cứng.
Đầu kết nối (Connectors)
Mọi thiết bị có một upstream &amp;ldquo;chảy&amp;rdquo;đến host, và mọi host có một downstream &amp;ldquo;chảy&amp;rdquo; thiết bị. Các điểm kết nối với Upstream, downstream không phải ở dạng hoán đổi cơ học thì thế phải các kết nối vòng không hợp lệ (illegal loopback connections) như downstream chảy đến downstream chẳng hạn phải được loại bỏ ở hubs.</description>
    </item>
    
    <item>
      <title>SCSI - Giao tiếp với USB Memory</title>
      <link>https://blog.lazytrick.com/post/2016-03-15-scsi-giao-tiep-voi-usb-memory/</link>
      <pubDate>Tue, 15 Mar 2016 14:54:41 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2016-03-15-scsi-giao-tiep-voi-usb-memory/</guid>
      <description>Gần đây, do phải tìm hiểu khả năng porting USB Memory Driver sang NORTi nên đã có dịp tìm hiểu và tự confirm trên code một số điều liên quan đến thiết bị nhớ USB (hay ta vẫn gọi là USB Flash Memory). &amp;ldquo;USB Flash Memory&amp;rdquo; bao gồm USB: là tên giao diện cả mềm, cứng; Flash : là chất liệu của chip nhớ, Memory : là chỉ thiết bị nhớ nói chung.</description>
    </item>
    
    <item>
      <title>Trường Remain Length trong MQTT Fixed Header</title>
      <link>https://blog.lazytrick.com/post/2016-03-08-truong-remain-length-trong-mqtt-fixed-header/</link>
      <pubDate>Tue, 08 Mar 2016 15:39:23 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2016-03-08-truong-remain-length-trong-mqtt-fixed-header/</guid>
      <description>Trước kia, đã từng học rất nhiều thứ về hệ điều hành. Nhưng hầu hết những nguyên lý được nói đến đều lấy Windows, hoặc Linux(*Unix), hoặc Mac làm tham chiếu đến những nội dung được học.
Ai cũng biết sẽ có một phần mềm hệ thống gọi là Kernel, nó rất quan trọng nó lập lịch các tiến trình, quản lý bộ nhớ, các driver&amp;hellip; Thực sự cũng từng đọc code tham khảo (dành cho Academy của M$ về Windows NT), nhưng thực sự vẫn chưa có một hình dung tương đối về cái Kernel kia.</description>
    </item>
    
    <item>
      <title>RTOS - Hầu hết giống như một thư viện</title>
      <link>https://blog.lazytrick.com/post/2016-03-01-do-uu-tien-cua-ngat-trong-nortiitron/</link>
      <pubDate>Tue, 01 Mar 2016 15:25:24 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2016-03-01-do-uu-tien-cua-ngat-trong-nortiitron/</guid>
      <description>Trước kia, đã từng học rất nhiều thứ về hệ điều hành. Nhưng hầu hết những nguyên lý được nói đến đều lấy Windows, hoặc Linux(*Unix), hoặc Mac làm tham chiếu đến những nội dung được học.
Ai cũng biết sẽ có một phần mềm hệ thống gọi là Kernel, nó rất quan trọng nó lập lịch các tiến trình, quản lý bộ nhớ, các driver&amp;hellip; Thực sự cũng từng đọc code tham khảo (dành cho Academy của M$ về Windows NT), nhưng thực sự vẫn chưa có một hình dung tương đối về cái Kernel kia.</description>
    </item>
    
    <item>
      <title>Một chút về RGB VGA, Digital RGB</title>
      <link>https://blog.lazytrick.com/post/2016-02-03-mot-chut-ve-rgb-vga-digital-rgb/</link>
      <pubDate>Wed, 03 Feb 2016 15:31:36 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2016-02-03-mot-chut-ve-rgb-vga-digital-rgb/</guid>
      <description>MCU phải giao tiếp với chip ADV7401, tìm mãi tài liệu tiếng Việt mà không tìm được (chắc do tìm kém). Mất hơn 1 hôm mới hiểu được cơ bản chức năng của nó làm gì.
Mô tả ngắn gọn ở đây để sau đỡ quên vậy:
ADV7401 : Chip chuyển đổi tín hiệu truyền hình Analog (PAL, NTSC&amp;hellip;) sang dạng số, hoặc số hóa tín hiệu RGB/VGA về dạng Digital RGB.</description>
    </item>
    
    <item>
      <title>Hiểu thêm về HID Report Descriptor</title>
      <link>https://blog.lazytrick.com/post/2016-01-28-hieu-them-ve-hid-report-descriptor/</link>
      <pubDate>Thu, 28 Jan 2016 15:44:23 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2016-01-28-hieu-them-ve-hid-report-descriptor/</guid>
      <description>Đang hì hục đọc sách các kiểu con đà điều để hiểu kĩ hơn về HID Report Descriptor (Đặc tả cấu trúc dữ liệu trao đổi của HID). Thì tìm được bài này, nó giải thích hầu hết những chỗ khó hiểu một cách dễ hiểu, và đặc biệt có ví dụ minh họa.
Giờ xin dịch lại bài này một cách khái quát nhất.
Vì để hiểu bài này cần biết đến một vài khái niệm về USB, về HID Device, nữa nên để xin tóm tắt nội dung bên dưới như sau.</description>
    </item>
    
    <item>
      <title>Bộ nhớ Flash</title>
      <link>https://blog.lazytrick.com/post/2016-01-25-bo-nho-flash-se-viet/</link>
      <pubDate>Mon, 25 Jan 2016 14:29:09 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2016-01-25-bo-nho-flash-se-viet/</guid>
      <description>Để thành 1 bài thì hơi nhiều, những thôi đã để thành 1 bài thì vẫn phải viết.
Lập trình với bộ nhớ Flash Nếu là Flash memory, khi lập trình nhất định phải có một thao tác xóa trước một thao tác ghi. Sau khi xóa, giá trị tất cả các ô nhớ là 1, tức là nếu đọc ra ta sẽ thấy toàn 0xFF thôi.
Serial Flash Có rất nhiều loại Flash, nhưng trên các ứng dụng embedded thì Serial Flash được sử dụng phổ biến nhất.</description>
    </item>
    
    <item>
      <title>I2C - Kế thừa UART và SPI (sẽ viết)</title>
      <link>https://blog.lazytrick.com/post/2016-01-25-i2c-ke-thua-uart-va-spi/</link>
      <pubDate>Mon, 25 Jan 2016 14:22:56 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2016-01-25-i2c-ke-thua-uart-va-spi/</guid>
      <description></description>
    </item>
    
    <item>
      <title>USB cho Dev (Chp.01 - Giới thiệu)</title>
      <link>https://blog.lazytrick.com/post/2016-01-25-usb-driver-va-usb-device-firmware-se-viet/</link>
      <pubDate>Mon, 25 Jan 2016 14:18:10 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2016-01-25-usb-driver-va-usb-device-firmware-se-viet/</guid>
      <description>USB - Một chuẩn giao tiếp phổ biến nhất (tính đến 2016), hãy cùng tìm hiểu một chút về nó. Bài này không phải dành cho người sử dụng bằng nhứng con số về tốc độ, hay cách cắm vật lý. Bài này là một bài dịch, mình thấy cần rất hữu ích khi bắt đầu phát triển sử dụng USB.
Link gốc tại http://www.beyondlogic.org/usbnutshell/usb1.shtml
Tóm tắt về USB Hiểu chuẩn USB để sử dụng trong phát triển Nếu bạn là người bắt đầu công việc phát triển sử dụng USB, thì quả thật nó không dễ dàng gì.</description>
    </item>
    
    <item>
      <title>Tầng thấp của USB</title>
      <link>https://blog.lazytrick.com/post/2016-01-25-tang-thap-cua-usb-se-viet/</link>
      <pubDate>Mon, 25 Jan 2016 14:17:00 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2016-01-25-tang-thap-cua-usb-se-viet/</guid>
      <description>USB - Khỏi cần nói thì nó cũng đã quá nổi tiếng về sự phổ biến rồi. Gần như mọi thứ đều mặc định phải có kết nối USB, cổng USB gần như là bắt buộc trên máy tính, và rất nhiều thiết bị điện tử ta thấy. Từ USB1.1 đến 2.0, rồi gần đây nhất là 3.0. Rồi gần đây người ta có nhắc nhiều đến USB Type C.</description>
    </item>
    
    <item>
      <title>Khái quát về FAT</title>
      <link>https://blog.lazytrick.com/post/2015-12-27-khai-quat-ve-fat/</link>
      <pubDate>Sun, 27 Dec 2015 13:39:16 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2015-12-27-khai-quat-ve-fat/</guid>
      <description>Trong quá trình porting sang hệ điều hành ITRON-based (NORTi), đã có dịp tìm hiểu về FAT, thấy bài của anh ELMちゃん này đầy đủ những thứ mình muốn biết về FAT nên sẽ dịch lại cả bài ở đây.
Link gốc: http://elm-chan.org/docs/fat.html
Trong tài liệu này, về cơ bản là dựa trên tài liệu vể FAT32 Spec , nhưng sẽ được giản luợc và bô sung thêm phần giải thích khái niệm mà bản gốc không có.</description>
    </item>
    
    <item>
      <title>[OE] Tại sao vẫn dùng FAT</title>
      <link>https://blog.lazytrick.com/post/2015-12-27-oe-tai-sao-van-dung-fat/</link>
      <pubDate>Sun, 27 Dec 2015 13:17:33 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2015-12-27-oe-tai-sao-van-dung-fat/</guid>
      <description>Bài hôm nay nói về một hệ thống file được sử dụng khá nhiều trên các phần mềm chạy trên mạch.
Dù hiện nay có rất nhiều hệ thống file được nói đến như NTFS, Ext3, Ext4&amp;hellip;Hầu hết những hệ thống file đó được sử dụng chủ yếu trên các máy có năng lực tính toán cao và khả năng lưu trữ lớn. Thế còn với những máy có năng lực tính toán hạn chế, dung lượng lưu trữ nhỏ thì sẽ sử dụng hệ thống file nào.</description>
    </item>
    
    <item>
      <title>[USB]Các khái niệm về USB</title>
      <link>https://blog.lazytrick.com/post/2015-12-22-usbcac-khai-niem-ve-usb/</link>
      <pubDate>Tue, 22 Dec 2015 16:41:13 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2015-12-22-usbcac-khai-niem-ve-usb/</guid>
      <description>Kết nối USB, chắc chắn ai cũng biết. Mỗi người đểu sở hữu ít nhất một thiết bị có kết nối này.
Tôi cũng đã từng nghĩ nó sẽ khá dễ dàng để hiểu, để lập trình giống như người dùng vẫn hiểu về nó.
Đúng là với người dùng cuối, một thiết bị có kết nối thì khả năng có nó có thể kết với máy tính như smartphone, máy nghe nhạc, bộ sạc&amp;hellip;.</description>
    </item>
    
    <item>
      <title>Giao thức MQTT</title>
      <link>https://blog.lazytrick.com/post/2015-08-04-giao-thuc-mqtt/</link>
      <pubDate>Tue, 04 Aug 2015 14:56:02 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2015-08-04-giao-thuc-mqtt/</guid>
      <description>Bài này dự là sẽ dịch lại đặc của giao thức MQTT này, nhằm có một cách hiểu tổng quát về MQTT protocol.
Link gốc :
http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html
Update 2017/03/24: Bản dịch của MQTT đã được chuyển sang địa chỉ sau:
http://minatu2d.github.io/</description>
    </item>
    
    <item>
      <title>Cơ bản về pthread</title>
      <link>https://blog.lazytrick.com/post/2015-07-16-dung-pthread-theo-cac-da-nen-tang-den-muc-nao/</link>
      <pubDate>Thu, 16 Jul 2015 23:18:38 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2015-07-16-dung-pthread-theo-cac-da-nen-tang-den-muc-nao/</guid>
      <description>&lt;p&gt;Ngày trước, khi tìm hiểu về Java, rồi Qt, nghe đến thuật ngữ đa nền (multi-platform). kì thực cái multi platform đó sẽ được phát triển như thế nào. Nó có thực sự dễ dàng như họ quảng cáo? Họ thường quảng cáo rằng, chỉ cần thay đổi cấu hình bằng một vài click chuột thì có thể build lại một dự án bất kì của Qt từ OS này sang OS khác.&lt;/p&gt;

&lt;p&gt;Khi gặp những ứng dụng chạy đa nền tảng mình mới thấy quảng cáo chỉ miêu tả rất nhỏ thôi. Các dự án thực tế luôn có cực kì nhiều vấn đề. Nó không phải là hello world mà chỉ bằng vài click là đa nền tảng được. Ta biết rằng, những thư viện như Qt hỗ trợ rất nhiều. Nhưng thông thường các dự án chỉ dùng 1 phần thôi, còn lại họ tự viết hoặc sử dụng lại ở đâu đó. Vì vậy, nếu nói một dự án pure Qt thì đương nhiên dễ dàng chuyển đổi giữa các platform. Còn một dự án không phải là pure Qt thì rất nhiều vấn đề phát sinh.&lt;/p&gt;

&lt;p&gt;Nói lan man rồi, phần chính của bài này là nói về &lt;strong&gt;pthread&lt;/strong&gt;.&lt;br /&gt;
Pthread được giới thiệu là thư viện implement chuẩn POSIX đặc tả việc tạo nhiều luồng tính toán song song.&lt;br /&gt;
Hầu hết các implement của pthread là trên Linux. Ta hiểu POSIX miểu tả các API ( tức là các tên hàm và chức năng của chúng). Khi viết các hàm đó, thì tùy mỗi nền tảng mà người ta sẽ có những các khác nhau để thực hiện được nhiệm vụ được miêu tả trong đặc tả của các hàm này.&lt;/p&gt;

&lt;p&gt;Trong bài này ta sẽ tìm hiểu một số thứ về pthread trên Linux và Window, chắc bài này sẽ khá đầu &amp;ldquo;lâu&amp;rdquo; nên thui mỗi hôm viết một tẹo vậy.&lt;/p&gt;

&lt;p&gt;Thứ tự thực hiện sẽ như sau:&lt;/p&gt;

&lt;p&gt;I. Những thứ cần biết về pthread API&lt;br /&gt;
II. Test thử trên Window.&lt;br /&gt;
III. Test thử trên Linux.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>