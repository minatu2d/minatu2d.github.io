<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Compile on Lazytrick - Limited size memory of mind</title>
    <link>https://blog.lazytrick.com/categories/compile/</link>
    <description>Recent content in Compile on Lazytrick - Limited size memory of mind</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>&amp;copy; 2019 Minatu2d</copyright>
    <lastBuildDate>Mon, 10 Apr 2017 14:07:48 +0900</lastBuildDate><atom:link href="https://blog.lazytrick.com/categories/compile/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Build, chạy nhân Linux trong QEMU ARM</title>
      <link>https://blog.lazytrick.com/post/2017-04-10-build-chay-nhan-trong-qemu-arm/</link>
      <pubDate>Mon, 10 Apr 2017 14:07:48 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2017-04-10-build-chay-nhan-trong-qemu-arm/</guid>
      <description>Chạy một bản Linux tối giản trên Qemu ARM
Bài này sẽ làm một ví dụ để chỉ ra sự liên quan giữa
các thành phần của một hệ thống Linux thông qua
việc build, chạy Kernel trên board vexpress-a9 mô phỏng bằng Qemu.
Đó là Kernel, Root file system, Busybox, Init.
 1. &amp;ldquo;Chém&amp;rdquo; chút về quá trình khởi động của Linux   Về cơ bản, quá trình khởi động Linux có 2 giai đoạn.</description>
    </item>
    
    <item>
      <title>So sánh giữa Buildroot và Yocto Project</title>
      <link>https://blog.lazytrick.com/post/2017-01-20-so-sanh-buildroot-va-yocto-project/</link>
      <pubDate>Fri, 20 Jan 2017 01:22:46 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2017-01-20-so-sanh-buildroot-va-yocto-project/</guid>
      <description>Bài này sẽ dịch lại Slide thảo luận giữa 2 diễn giả là Alexandre Belloni, Thomas Petazzoni
từ Free Electrons tại Embedded Linux Conference 2016.
So sánh giữa Buildroot và OpenEmbedded/Yocto Project
1. Điểm chung  Đều là build-system cho Embedded Linux.
Mục tiêu là có thể customize, build hoàn chỉnh một Embedded Linux System.
Bao gồm: filesystem, toolchain, kernel, bootloaders Đều được build từ source Sử dụng cross-compilation Rất actively trong cả dự án đang maintained và phát triển.</description>
    </item>
    
    <item>
      <title>Thực hiện 4 Stage khi Compile bằng tay (Manual)</title>
      <link>https://blog.lazytrick.com/post/2017-01-08-thuc-hien-4-stage-khi-compile-bang-tay-manual/</link>
      <pubDate>Sun, 08 Jan 2017 06:18:19 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2017-01-08-thuc-hien-4-stage-khi-compile-bang-tay-manual/</guid>
      <description>Ta đã có bài giới thiệu về 4 Stage khi Compiling rồi. Đầu ra của Stage trước sẽ là đầu vào của Stage sau.
Trong compile thông thường dạng
$gcc -o HelloWorld HelloWorld.c Với câu lệnh trên,ta sẽ không thấy kết quả của 3 Stage đầu tiên.
Để hiểu rõ hơn, chúng ta hãy thử thực hiện các Stage bằng tay xem liệu ta có thể tạo ra file chạy như câu lệnh compile trên hay không.</description>
    </item>
    
    <item>
      <title>4 Stage khi biên dịch HelloWorld.c</title>
      <link>https://blog.lazytrick.com/post/2017-01-01-4-stage-khi-bien-dich-helloworld-c/</link>
      <pubDate>Sun, 01 Jan 2017 22:00:04 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2017-01-01-4-stage-khi-bien-dich-helloworld-c/</guid>
      <description>Gần đây, phải giải quyết giúp một vài vấn đề liên quan đến Cross-Compile. Có tìm hiểu kĩ một chú về Compiler, Linker, và Loader.
Bài này xin nói về cơ bản về quá trình biên dịch một file source code (.c) sang dạng chạy được.
Ví dụ: từ HelloWorld.c thành HelloWorld và chạy được như ví dụ dưới đây.
HelloWorld.c
#include int main() { print(&amp;#34;Hello World \n&amp;#34;); return 0; } Kết quả chạy:</description>
    </item>
    
    <item>
      <title>Một chút hiểu thêm về &#34;Hello World&#34; trong C.</title>
      <link>https://blog.lazytrick.com/post/2016-12-21-mot-chut-hieu-them-ve-hello-world-trong-c/</link>
      <pubDate>Wed, 21 Dec 2016 05:31:09 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2016-12-21-mot-chut-hieu-them-ve-hello-world-trong-c/</guid>
      <description>Gần đây, gặp một số vấn đề về Loader-Linker giữa môi trường build và môi trường chạy trong Cross-Compiling.
Có thể bất kì chương nào trong Linux cũng vậy. Nhưng chỉ xét một chường trình được build bằng C thì
một chương trình sẽ được chạy 2 cách dưới đây
1. Chương trình hoàn toàn là tĩnh  Không có symbol nào cần phải được (resolved) trước khi chạy. Không yêu cầu bất cứ một thư viện run-time nào.</description>
    </item>
    
    <item>
      <title>Lỗi về Case-sensive khi biên dịch C (gcc)</title>
      <link>https://blog.lazytrick.com/post/2016-12-01-loi-ve-case-sensive-khi-bien-dich-c-gcc/</link>
      <pubDate>Thu, 01 Dec 2016 13:08:38 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2016-12-01-loi-ve-case-sensive-khi-bien-dich-c-gcc/</guid>
      <description>Khi phát triển các ứng dụng trên Linux, nhúng Linux, mình hầu như cài đặt và sử dụng một máy ảo (tạo bằng VMWare hoặc VirtualBox). Cài trình biên dịch GCC lên đó.
Hầu như mình có thể làm mọi việc trên môi trường máy ảo đó trừ quản lý source.
Vì cty mình vẫn sử dụng SVN với Client là Tortoise. Linux cũng có rất nhiều công cụ tuơng tự Tortoise nhưng để tránh những vấn đề không cần thiết, có thể làm phiền người khác liên quan đến tương thích SVN, mình vẫn chọn quản lý bằng Tortoise trên Windows.</description>
    </item>
    
    <item>
      <title>&#34;Data structure alignment&#34; là gì? Tại sao phải hiểu nó khi code C.</title>
      <link>https://blog.lazytrick.com/post/2016-10-26-data-structure-alignment-la-gi-tai-sao-phai-hieu-no-khi-code-c/</link>
      <pubDate>Wed, 26 Oct 2016 06:50:13 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2016-10-26-data-structure-alignment-la-gi-tai-sao-phai-hieu-no-khi-code-c/</guid>
      <description>Đây là một chủ đề hay, có rất nhiều resource bằng tiếng Việt khá dễ hiểu rồi.
Bài này chỉ mô tả ngắn gọn một chút cùng với vài ví dụ thực nghiệm để hiểu các khái niệm về cơ bản về Data Structure Aligment.
Giả sử ta có một cấu trúc sau:
#include &amp;lt;stdint.h&amp;gt; typedef struct { uin8_t mem1; uin8_t mem2; uin32_t mem3; }ST_FOOL_1; typedef struct { uin8_t mem1; uin8_t mem2; uin8_t mem3; uin8_t mem4; uin8_t mem5; }ST_FOOL_2; Cấu trúc ST_FOOL_1 sẽ được miêu tả trong 6 byte?</description>
    </item>
    
    <item>
      <title>Phân biệt Build vs Host vs Target</title>
      <link>https://blog.lazytrick.com/post/2016-08-03-cac-khai-niem-trong-cross-compiling/</link>
      <pubDate>Wed, 03 Aug 2016 01:24:36 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2016-08-03-cac-khai-niem-trong-cross-compiling/</guid>
      <description>Khái niệm Cross-compiling là rất phổ biến khi phát triển các hệ thống nhúng.
Với người mới, hiểu rõ khái niệm là rất quan trọng.
Bài này sẽ cố gắng phân biệt 3 khái niệm về môi trường. Đó là Host Enviroment, Build Enviroment, và Target Enviroment. Có thể dịch nôm na là Môi trường chủ, Môi trường biên dịch, và Môi trường chạy đích.
Vì có thể dẫn đến hiểu nhầm hoặc không rõ nghĩa nên chúng ta nên sử dụng trực tiếp thì hơn.</description>
    </item>
    
    <item>
      <title>2 cách sử dụng thư viện trong Linux</title>
      <link>https://blog.lazytrick.com/post/2016-06-12-2-cach-su-dung-thu-vien-trong-linux/</link>
      <pubDate>Sun, 12 Jun 2016 13:20:13 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2016-06-12-2-cach-su-dung-thu-vien-trong-linux/</guid>
      <description>Mình đang gặp 1 vấn đề là 1 hàm F1() trong thư viện động mình viết (lib1.so) không hoạt động đúng như mong muốn. Trong hàm _F1()_có gọi một loại hàm F21(), F22(), F23()&amp;hellip;F2n() từ 1 thư viện tĩnh (lib2.a) khác.
Khi build không gặp lỗi,
Khi biên dịch thư viện động này với 1 file sample.c để chưa main() để chạy thử và gọi hàm _F1() _từ thư viện động lib1.</description>
    </item>
    
    <item>
      <title>CMake - Một ví dụ đơn giản</title>
      <link>https://blog.lazytrick.com/post/2015-08-16-cmake-mot-vi-du-don-gian/</link>
      <pubDate>Sun, 16 Aug 2015 04:12:53 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2015-08-16-cmake-mot-vi-du-don-gian/</guid>
      <description>Trong bài tôi đã giới thiệu qua về CMake. Như ta đã biết nó cung cấp tính tăng giúp việc sinh ra Makefile một cách hiệu quả. Nhất là đối với các dự án phức tạp. Nó cũng cung cấp thêm các bộ sinh khác để sinh cấu trúc quản lý source cho các IDE khác nhau như Visual Studio, KDE.
Trong giới hạn, tôi sẽ nói về việc sử dụng CMake để build một simple project trên cả Windows và Linux.</description>
    </item>
    
    <item>
      <title>CMake - Công cụ hỗ trợ việc build source trên nhiều platform.</title>
      <link>https://blog.lazytrick.com/post/2015-08-02-cmake-cong-cu-ho-tro-viec-build-source-tren-nhieu-platform/</link>
      <pubDate>Sun, 02 Aug 2015 20:38:27 +0900</pubDate>
      
      <guid>https://blog.lazytrick.com/post/2015-08-02-cmake-cong-cu-ho-tro-viec-build-source-tren-nhieu-platform/</guid>
      <description>Đuợc làm việc cùng những pro đầy kinh nghiệm thực sự rất thú vị, ngoài việc chia sẻ hiểu biết của mình, còn đuợc hóng nhiều kĩ năng sử dụng tool của các pro nữa. Mình thấy rằng, không có tool nào gọi là thần thành, mọi tool chỉ giúp tăng tốc độc với những người mới và không đủ thời gian để hiểu sâu. Còn với những người đã nhiều kinh nghiệm, họ sử dụng tool theo các điểm mạnh của chúng và kết hợp rất nhiều tool một cách nhịp nhàng sao cho công việc tiến hành nhanh nhất.</description>
    </item>
    
  </channel>
</rss>
